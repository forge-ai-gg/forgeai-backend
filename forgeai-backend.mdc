---
description: 
globs: 
alwaysApply: false
---
 # Solana Trade Execution Framework Rules

## Development Approach

### Test-Driven Development
- Each component must be developed using a test-driven approach
- Write tests before implementing functionality
- Tests should be in the `__tests__` directory with corresponding test files
- Each trading step must have comprehensive unit tests covering edge cases
- Use mock data and dependency injection to isolate components for testing
- Aim for high test coverage (>80%) for all trading functionality

## Core Workflow

### 1. Initialization (Every 1 Minute)
- Load agent configuration and trading strategy assignments
- Initialize Solana RPC connection with fallbacks
- Load cached data from previous cycles (handled by eliza cache handler)
- Validate wallet and API keys
- Tests should verify proper initialization with various configurations

### 2. Portfolio Analysis
- Retrieve current wallet holdings and open positions
- Track all open positions
- Monitor position performance (realtime PnL for open positions)
- Calculate portfolio metrics
- Assess risk exposure
- Check position limits
- Tests should verify handling of empty wallets, multiple tokens, and various position states

### 3. Price History Collection
- Fetch current market prices using birdeye data (1-minute cache)
- Get token metadata and liquidity data for tokens in the trading strategy
- Calculate technical indicators using 'technical-indicators' npm library
- Fetch trust scores and security metrics (future)
- Tests should verify handling of various time periods, missing data, and API failures

### 4. Strategy Evaluation
- Evaluate trading signals based on price history and indicators
- Calculate position sizes based on portfolio and risk parameters
- Check risk parameters
- Generate trade recommendations (buy/sell signals)
- Validate against portfolio limits
- Tests should verify various strategy types, signal generation, and risk management

### 5. Trade Execution
- Perform preflight checks on trade decisions
- Get Jupiter DEX quote for approved trades
- Validate slippage and price impact
- Simulate transaction before execution
- Execute and confirm transaction
- Tests should verify transaction success/failure, slippage protection, and error handling

### 6. Logging and Memory
- Build structured log messages summarizing the trading cycle
- Record trading context for future reference and analysis
- Log final results with detailed metrics
- Tests should verify proper data recording and log formatting

## Trading Step Implementation

Each trading step follows a consistent pattern:
1. Takes a TradingContext as input
2. Performs a specific operation
3. Returns an updated TradingContext

This design enables:
- Independent testing of each step
- Clear separation of concerns
- Easy composition of steps into a workflow
- Comprehensive test coverage of edge cases

## Safety Parameters

### 1. Trading Limits
- Minimum trade: 0.001 SOL
- Maximum position size: 10% of token liquidity
- Maximum slippage: 3%
- Minimum liquidity: $1000
- Minimum 24h volume: $2000 
- Minimum trust score: 0.4 (future)
- Stop loss: 20% (future)
- Take profit: 12% (future)
- Trailing stop: 20% (future)
- Maximum active positions: 5 (future)

### 2. Error Handling
- Maximum retries: 3
- Backoff base: 1000ms
- Circuit breaker threshold: 5 failures
- Recovery actions for common errors:
  - Insufficient funds: Abort
  - High slippage: Retry
  - RPC error: Switch endpoint
  - Transaction error: Analyze and retry
- Tests should verify proper error handling and recovery mechanisms

## Performance Optimization

### 1. Caching Strategy
- Price data: 5-minute cache
- Technical indicators: 5-minute cache
- Portfolio data: 1-minute cache
- Token metadata: 1-hour cache

### 2. Batch Operations
- Batch all token approvals (future)
- Batch price updates (future)
- Combine similar trades (future)
- Bulk position updates (future)

### 3. RPC Optimization
- Connection pooling (future)
- Request batching (future)
- Fallback endpoints (future)
- Rate limiting (future)

## Monitoring

### 1. Health Checks
- API connectivity status
- Balance reconciliation
- Order execution latency
- Strategy performance metrics
- Memory usage monitoring
- RPC connection health

### 2. Alerts
- Execution failures
- Slippage exceeding thresholds
- Unusual price movements
- Position limit breaches
- RPC connection issues
- Memory usage warnings

## Documentation Requirements

### 1. Trade Logging
- All trades should be logged using the TradeHistory table and tied to a strategy
- Data should include token swap details including fees and price impact
- Entry/exit reasons should be documented
- Performance metrics should be calculated and stored
- Transaction hash/signatures should be recorded
- Slippage details should be included

## Testing Requirements

### 1. Unit Tests
- Each trading step should have comprehensive unit tests:
  - Portfolio retrieval: Test empty wallets, multiple tokens, API failures
  - Price history: Test various time periods, missing data, API failures
  - Trade evaluation: Test strategy types, buy/sell signals, position sizing
  - Trade execution: Test transaction success/failure, slippage protection, retries
  - Logging and memory: Test data integrity and persistence

### 2. Integration Tests
- Test the complete trading workflow with various scenarios
- Test proper sequencing of steps and context propagation
- Test RPC connectivity and DEX integration
- Test position tracking across multiple cycles
- Test memory management and cache functionality
- Test error recovery and circuit breakers

### 3. Performance Tests
- High frequency updates
- Large position handling
- Concurrent trade execution
- Memory leak detection
- RPC failover
- Cache efficiency

## Integration Points

### 1. Required Services
- Jupiter DEX aggregator
- Birdeye price feeds
- Trust score provider
- Technical analysis engine
- Portfolio management system
- RPC node provider

### 2. Optional/Future Services
- Social sentiment analysis
- News feed integration
- Whale wallet tracking
- Market depth analysis
- MEV protection
- Gas optimization