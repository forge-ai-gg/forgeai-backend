---
description: Creating functionality in the trading execution steps of the agents auto client workflow
globs: 
alwaysApply: false
---
# Solana Trade Execution Framework Rules

## Development Approach

### Test-Driven Development
- Each component must be developed using a test-driven approach
- Write tests before implementing functionality
- Tests should be in the `__tests__` directory with corresponding test files
- Only use Vitest and not Jest for tests and mocking
- Each trading step must have comprehensive unit tests covering edge cases
- Use mock data and dependency injection to isolate components for testing
- Aim for high test coverage (>80%) for all trading functionality
- At the end of each major change to any tests, you should its working by running `pnpm test:unit` and `pnpm test:int` and looking for failures

### Database Access
- For any database operations or queries, use the TypeScript SQL query executor at `packages/client-auto/scripts/query-agents.ts`
- This tool allows executing arbitrary SQL queries against the database using Prisma's raw query functionality
- When information about database data is needed, ALWAYS use this tool instead of creating new database connections
- Run queries using the shell script: `./packages/client-auto/scripts/run-query.sh 'YOUR SQL QUERY HERE'`
- For parameterized queries use: `./packages/client-auto/scripts/run-query.sh 'SELECT * FROM "Table" WHERE "column" = $1' parameter_value`
- The tool supports all SQL operations including SELECT, INSERT, UPDATE, and DELETE
- Reference `packages/client-auto/prisma/schema.prisma` to understand the data structure
- For detailed usage instructions, refer to `packages/client-auto/scripts/SQL_QUERY_README.md`
- Example queries:
  - List all agents: `./packages/client-auto/scripts/run-query.sh 'SELECT * FROM "Agent" LIMIT 10'`
  - Find specific transactions: `./packages/client-auto/scripts/run-query.sh 'SELECT * FROM "Transaction" WHERE "agentId" = $1' agent_id_here`
  - Complex joins: `./packages/client-auto/scripts/run-query.sh 'SELECT a.id, a.name, COUNT(t.id) as transaction_count FROM "Agent" a LEFT JOIN "Transaction" t ON a.id = t."agentId" GROUP BY a.id, a.name'`

### Cursor IDE Database Integration
- When a user asks for information about data in the database, Cursor should ALWAYS use the SQL query executor
- NEVER suggest creating new database connections or writing new database query scripts
- Instead, recommend using the existing `run-query.sh` script with appropriate SQL queries
- For all database-related questions, first check the schema at `packages/client-auto/prisma/schema.prisma`
- Then construct an appropriate SQL query to retrieve the requested information
- Always use parameterized queries when dealing with user input to prevent SQL injection
- Suggest running the query using: `./packages/client-auto/scripts/run-query.sh 'YOUR SQL QUERY'`
- For complex data needs, suggest appropriate JOINs and aggregations in the SQL query
- When displaying results, recommend using the JSON output format provided by the tool
- If the user needs to modify data, suggest appropriate INSERT, UPDATE, or DELETE queries
- For repeated queries, suggest creating a shell script that calls the query tool with different parameters

## Core Workflow

### 1. Initialization (Every 1 Minute)
- Load agent configuration and trading strategy assignments
- Initialize Solana RPC connection with fallbacks
- Load cached data from previous cycles (handled by eliza cache handler)
- Validate wallet and API keys
- Tests should verify proper initialization with various configurations

### 2. Portfolio Analysis
- Retrieve current wallet holdings and open positions
- Track all open positions
- Monitor position performance (realtime PnL for open positions)
- Calculate portfolio metrics
- Assess risk exposure
- Check position limits
- Tests should verify handling of empty wallets, multiple tokens, and various position states

### 3. Price History Collection
- Fetch current market prices using birdeye data (1-minute cache)
- Get token metadata and liquidity data for tokens in the trading strategy
- Calculate technical indicators using 'technical-indicators' npm library
- Fetch trust scores and security metrics (future)
- Tests should verify handling of various time periods, missing data, and API failures

### 4. Strategy Evaluation
- Evaluate trading signals based on price history and indicators
- Calculate position sizes based on portfolio and risk parameters
- Check risk parameters
- Generate trade recommendations (buy/sell signals)
- Validate against portfolio limits
- Tests should verify various strategy types, signal generation, and risk management

### 5. Trade Execution
- Perform preflight checks on trade decisions
- Get Jupiter DEX quote for approved trades
- Validate slippage and price impact
- Simulate transaction before execution
- Execute and confirm transaction
- Tests should verify transaction success/failure, slippage protection, and error handling

### 6. Logging and Memory
- Build structured log messages summarizing the trading cycle
- Record trading context for future reference and analysis
- Log final results with detailed metrics
- Tests should verify proper data recording and log formatting

## Trading Step Implementation

Each trading step follows a consistent pattern:
1. Takes a TradingContext as input
2. Performs a specific operation
3. Returns an updated TradingContext

This design enables:
- Independent testing of each step
- Clear separation of concerns
- Easy composition of steps into a workflow
- Comprehensive test coverage of edge cases

## Safety Parameters

### 1. Trading Limits
- Minimum trade: 0.001 SOL
- Maximum position size: 10% of token liquidity
- Maximum slippage: 3%
- Minimum liquidity: $1000
- Minimum 24h volume: $2000 
- Minimum trust score: 0.4 (future)
- Stop loss: 20% (future)
- Take profit: 12% (future)
- Trailing stop: 20% (future)
- Maximum active positions: 5 (future)

### 2. Error Handling
- Maximum retries: 3
- Backoff base: 1000ms
- Circuit breaker threshold: 5 failures
- Recovery actions for common errors:
  - Insufficient funds: Abort
  - High slippage: Retry
  - RPC error: Switch endpoint
  - Transaction error: Analyze and retry
- Tests should verify proper error handling and recovery mechanisms

## Performance Optimization

### 1. Caching Strategy
- Price data: 5-minute cache
- Technical indicators: 5-minute cache
- Portfolio data: 1-minute cache
- Token metadata: 1-hour cache

### 2. Batch Operations
- Batch all token approvals (future)
- Batch price updates (future)
- Combine similar trades (future)
- Bulk position updates (future)

### 3. RPC Optimization
- Connection pooling (future)
- Request batching (future)
- Fallback endpoints (future)
- Rate limiting (future)

## Monitoring

### 1. Health Checks
- API connectivity status
- Balance reconciliation
- Order execution latency
- Strategy performance metrics
- Memory usage monitoring
- RPC connection health

### 2. Alerts
- Execution failures
- Slippage exceeding thresholds
- Unusual price movements
- Position limit breaches
- RPC connection issues
- Memory usage warnings

## Documentation Requirements

### 1. Trade Logging
- All trades should be logged using the TradeHistory table and tied to a strategy
- Data should include token swap details including fees and price impact
- Entry/exit reasons should be documented
- Performance metrics should be calculated and stored
- Transaction hash/signatures should be recorded
- Slippage details should be included

## Testing Requirements

### 1. Unit Tests
- Each trading step should have comprehensive unit tests:
  - Portfolio retrieval: Test empty wallets, multiple tokens, API failures
  - Price history: Test various time periods, missing data, API failures
  - Trade evaluation: Test strategy types, buy/sell signals, position sizing
  - Trade execution: Test transaction success/failure, slippage protection, retries
  - Logging and memory: Test data integrity and persistence

### 2. Integration Tests
- Test the complete trading workflow with various scenarios
- Test proper sequencing of steps and context propagation
- Test RPC connectivity and DEX integration
- Test position tracking across multiple cycles
- Test memory management and cache functionality
- Test error recovery and circuit breakers

### 3. Performance Tests
- High frequency updates
- Large position handling
- Concurrent trade execution
- Memory leak detection
- RPC failover
- Cache efficiency

## Integration Points

### 1. Required Services
- Jupiter DEX aggregator
- Birdeye price feeds
- Trust score provider
- Technical analysis engine
- Portfolio management system
- RPC node provider

### 2. Optional/Future Services
- Social sentiment analysis
- News feed integration
- Whale wallet tracking
- Market depth analysis
- MEV protection
- Gas optimization